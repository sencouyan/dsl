外部DSL的实现载体

外部DSL跟内部DSL一样，都是在已有的领域模型外面覆盖一层抽象，差别在于怎样实现这层抽象。

外部DSL会自行建立一套语言处理设施，包括语法分析器，词法分析器和处理逻辑。

DSL的自定义语法需要有配套的语法分析器。

分析引擎首先对输入流进行词法分析，将其转化为可识别的词法单元（token）。词法单元在语法上也称为终结符号（terminal）。

随后这些词法单元作为语法正确的语句，被送入产生式规则（production rule）进行处理。


DSL脚本 --> 语法分析基础设施 --> 目标操作
            - 词法分析
            - 语法分析
            - 抽象语法树
            - 代码生成

DSL并不一定需要非常复杂精密的语法分析基础设施。对于简单的领域语言，用字符串处理器、正则表达式处理器等简单的数据结构来充当语法分析引擎的做法并不罕见。
此时将词法分析、语法分析、代码生成等操作步骤整合到一起往往是合理的。

以上的设计无法很好地适应较复杂的情况。在需求很简单，且复杂性不会增加的情况下，我们可以选择这种大包大揽的实现形式。可惜世界上的问题不都是简单的。
解决复杂性的唯一途径是用不同模块实现不同任务，并且引入适当程度的抽象。

## 对领域模型进行抽象

以上的全能型的语法分析基础设施至少要在它的单个抽象单元内执行以下任务：
1. 依据一套语法规则对输入进行分析
2. 语法经过分析后被保存为AST的形式
3. 对AST进行标注，将其充实为中间表示，为执行目标操作做好准备
4. 处理AST，执行代码生成等目标操作

让一个抽象单元承担这么多指责，负担实在是太重了。

1. 模块化
   我们可以试着从大盒子里分离出来一部分职责，让设计变得模块化一些。

   - 对输入的DSL脚本进行语法分析                     -|
                                                   |- (核心的语法分析)
   - 生成抽象语法树                                 -|                 -|
                                                                      |- (领域抽象)
   - 对AST进行标注，准备好中间表示                                       -|

   - 处理AST并执行代码生成等操作                                                       - (尚需进一步分离的步骤)

2. 语义模型
   充实后的AST成为该领域的语义模型，前两部分之所以出现重叠，是因为核心语法分析过程要产生某种数据结构。
   下一阶段的处理过程向该数据结构注入领域知识。我们可以将领域的语义模型作为DSL处理流程中的一个核心抽象。

   DSL脚本 --> 语法分析器 --> 语义模型 --> 目标操作
               - 词法分析    - 充实后的领域模型
               - 语法分析    - 自底向上发展
                            - 由语法分析器产生和填充

   语义模型是DSL脚本处理后产生的，增加了领域语义的数据结构。它的结构与DSL的语法无关，更多的反映了系统的解答域模型。
   语义模型作为一层完美的抽象，分离了输入的语法导向的脚本结构和另一边的目标操作。

3. 填充语义模型
   语义模型是供应领域模型的仓库。语法分析器一边消耗DSL脚本的输入流，一边填充语义模型。
   语义模型的设计完全独立于DSL语法，而且模型的构成方式和内部DSL一样，由一些更小的抽象自底向上组合起来。
   外部DSL这种边做语法分析，边填充语义模型的方式，正是它与内部DSL的区别所在。
   我们在构造内部DSL时，先在宿主语言中建立较小的抽象，然后通过宿主语言本身的组合功能，建立更大的抽象。
   而对外部DSL来说，对语言的语法分析与产生较小的抽象同步进行，分析树成长壮大，意味着语义模型凝聚了更多的血肉，成为领域知识的具体表示。

## 语法分析器在外部DSL设计中的作用

待执行的DSL脚本被送入词法分析器，经过词法分析器的处理，输入流被划分为语法分析器能理解的可识别单元。当语法分析器顺利处理完所有的输入流，到达一个成功的终结状态，我们就说该语法分析器识别了输入的语言。

DSL脚本 --> 词法分析器 --------------> 语法分析器 ----------------------------->
                      词法单元                  进行语法分析并生成一颗语法分析树
                     <--------------
                      取下一个词法单元

### 语法分析器、语法分析器生成器

如果我们打算手工编写整个分析器，需要做两件事情：
- 定义语言的BNF语法
- 编写与该语法对应的语法分析器

手工编写有个弊端，写出来的全部语法都嵌入到了代码中。对语法的任何修改，以为着也要对相应的实现代码进行大幅修改。这种情况是实施编程的抽象层次过低的典型表现。
对于较复杂的语法分析器，利用语法分析器生成器要比直接手写更好一些。语法分析器生成器可以提高实施编程的抽象层次
- 按EBNF语法格式书写的语法规则
- 当语法规则识别成功时，希望执行的自定义操作

无论产生语法分析器的途径是手工编写，还是由生成器产生，指导语法分析器行为的始终是你所用语言的语法。
当分析器成功识别了语言，它会产生一颗语法分析树，将整个识别过程封装到这个递归的数据结构里面。如果我们在语法规则上附加了自定义动作，那么最后生成的分析树也会增加这些额外信息，形成语义模型。

### 语法制导翻译

如何识别语法？需要准备两套材料：
- 一套上下文无关语法。它的意义是决定哪些产生是有效的。                          作用：语法规定了撰写DSL的结构形式。只有按照文法规则定义写成的DSL脚本才是有效的
- 一套语义规则，作用对象是语法识别的符号的属性，这些规则在生成语义模型时发挥作用。  作用：在每一条语法规则里，我们可以进一步定义一些操作，当语法规则被识别时执行。操作可以是生成语法分析树，也可以是其他任意的触发行为，只要与被识别的规则相关即可。

             EBNF规则 -----> 语法分析器生成器 <----- 自定义操作
             (语言的语法)          |
                                  V
   |---------------------------------------------------------------
   |                                               进行语法分析并生 |
   |                                               成一颗语法分析树 |
-----> 词法分析器 --------------> 语法分析器 -------                 |
DSL脚本                                         |                  |
   |             词法单元                        |                 |
   |             <--------------                |                 |
   |             取下一个词法单元                 V                 |
   |--------------------------------------------------------------|
                                                |
                                                V
                      集成到核心应用程序 <----- 语义模型

### 使用ANTLR具体步骤

1. 确定词法要素，为ANTLR准备词法分析器     词法单元定义沿用了之前的交易指令处理DSL
2. 用EBNF标记编写文法规则                定义了DSL的语法，按照ANTLR的语法写成的文法规则的作用是识别有效的DSL语法，并在出现无效语法时给出异常。
3. 生成语义模型                         充实了语法规则的定义，通过插入自定义的Java代码，向语法分析过程中注入了语义操作。插入的一个个代码片段，实际上是搭建语义模型的部件。
4. 收尾                                自定义Java代码完成对Order抽象的建模。驱动代码利用ANTLR的基础设施，将DSL脚本送入前面建好的语法分析过程。

### 语法分析器的分类

假设你已经基本了解语言处理方面的概念，掌握语法分析技术，前瞻处理（look-ahead processing），分析树等基础知识。
Aho, Alfred V., Monica S. Lam, Ravi Sethi and Jeffrey D. Ullman, 2006. Compilers: Principles, Techniques, and Tools, Second Edition. Addison Wesley.

